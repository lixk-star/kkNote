# HTML&浏览器

## 一、行内元素、块级元素

### 1、块级元素的特点

* 总是在新行上开始，占据一整行；
* 高度，行高以及外边距和内边距都可控制；
* 宽带始终是与浏览器宽度一样，与内容无关；
* 它可以容纳内联元素和其他块元素。
* div ul ol li dl dt dd h1 h2 h3 h4 

### 2、行内元素的特点

* 和其他元素都在一行上；
* 高，行高及外边距和内边距部分可改变；
*  宽度只与内容有关；
* 行内元素只能容纳文本或者其他行内元素。
* 不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界。
* a b span img input select strong

## 二、history和hash两种路由

### 1、为什么要使用路由

* 现在的网络应用程序越来越多的使用AJAX异步请求完成页面的无缝刷新，导致浏览器的URL不会发生任何变化而完成了请求，从而破换了用户浏览体验。同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现，使用路由可以很好地解决这个问题。

  单页面富应用利用了JavaScript动态变换网页内容，避免了页面重载；路由则提供了浏览器地址变化，网页内容也跟随变化，两者结合起来则为我们提供了体验良好的单页面web应用。

### 2、前端路由实现方式

* 路由需要实现的三个功能
  * 当浏览器地址变化时，切换页面；
  * 点击浏览器【后退】、【前进】按钮，网页内容跟随变化；
  * 刷新浏览器，网页加载当前路由对应内容；
* 在单页面web网页中, 单纯的浏览器地址改变, 网页不会重载，如单纯的hash网址改变网页不会变化，因此我们的路由主要是通过监听事件，并利用js实现动态改变网页内容，有两种实现方式：
  * hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；
  * history模式：利用history API实现url地址改变，网页内容改变；
    * 它们的区别最明显的就是hash会在浏览器地址后面增加#号，而history可以自定义地址。

### 3、hash模式

* 使用`window.location.hash`属性及窗口的`onhashchange`事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。下面具体介绍几个使用过程中必须理解的要点：

  * hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如http://localhost/index.html#abc，这里的#abc就是hash；
  * 散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
  * 监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置hash值；
  * location.hash值的变化会直接反应到浏览器地址栏；

* 触发hashchange事件的几种情况：

  * 浏览器地址栏散列值的变化（包括浏览器的前进、后退）会触发window.location.hash值的变化，从而触发onhashchange事件；

  * 当浏览器地址栏中URL包含哈希如 `http://www.baidu.com/#home`，这时按下输入，浏览器发送`http://www.baidu.com/`请求至服务器，请求完毕之后设置散列值为#home，进而触发onhashchange事件；

  * 当只改变浏览器地址栏URL的哈希部分，这时按下回车，浏览器不会发送任何请求至服务器，这时发生的只是设置散列值新修改的哈希值，并触发onhashchange事件；

  * html中<a>标签的属性 href 可以设置为页面的元素ID如 #top，当点击该链接时页面跳转至该id元素所在区域，同时浏览器自动设置 window.location.hash 属性，地址栏中的哈希值也会发生改变，并触发onhashchange事件； 

    ```
    //设置 url 的 hash，会在当前url后加上'#abc'
    window.location.hash='abc';
    let hash = window.location.hash //'#abc'
    
    window.addEventListener('hashchange',function(){
    	//监听hash变化，点击浏览器的前进后退会触发
    })
    ```

    

### 4、history模式

* 概述

  * window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。
  * History 对象保存了当前窗口访问过的所有页面网址。通过 history.length 可以得出当前窗口一共访问过几个网址。
  * 由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。
  * 浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。

* 方法

  * `History.back()`：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。

  * `History.forward()`：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。

  * `History.go()`：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为`0`，相当于刷新当前页面。

  * History.pushState()：该方法用于在历史中添加一条记录。`pushState()`方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化。

    语法：history.pushState(object, title, url)

    ```javascript
    var data = { foo: 'bar' };
    history.pushState(data, '', '2.html');
    console.log(history.state)
    ```

  * History.replaceState(): 该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样。

    ```javascript
    //假定当前网页是 example.com/example.html。
    history.pushState({page: 1}, '', '?page=1')
    // URL 显示为 http://example.com/example.html?page=1
    
    history.pushState({page: 2}, '', '?page=2');
    // URL 显示为 http://example.com/example.html?page=2
    ```

* popstate 事件: 每当 history 对象出现变化时，就会触发 popstate 事件。

  * 仅仅调用`pushState()`方法或`replaceState()`方法 ，并不会触发该事件;

  * 只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用`History.back()`、`History.forward()`、`History.go()`方法时才会触发。

  * 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。

  * 页面第一次加载的时候，浏览器不会触发`popstate`事件。

    * 使用的时候，可以为`popstate`事件指定回调函数，回调函数的参数是一个 event 事件对象，它的 state 属性指向当前的 state 对象。

      ```js
      window.addEventListener('popstate', function(e) {
      	//e.state 相当于 history.state
      	console.log('state: ' + JSON.stringify(e.state));
      	console.log(history.state);
      });
      ```

      

## 三、导航流程

### 1、用户输入

* 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
* 如果判断输入内容符合URL规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 https://time.geekbang.org。

### 2. URL请求过程

* 首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。接下来就是利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）

#### **（1）重定向**

* 在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，一切又重头开始了。
* 在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求。

#### **（2）响应数据类型处理**

* 在处理了跳转信息之后，我们继续导航流程的分析。URL请求的数据类型，有时候是一个下载类型，有时候是正常的HTML页面，那么浏览器是如何区分它们呢？

  答案是Content-Type。Content-Type是HTTP头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。

* 所以，不同Content-Type的后续处理流程也截然不同。如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。由于Chrome的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

### 3. 准备渲染进程

* 通常情况下，打开新的页面都会使用单独的渲染进程；
* 如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程，渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 4. 提交文档

* 首先要明确一点，这里的“文档”是指URL请求的响应体数据。
* 提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
* 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
* 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

### 5. 渲染阶段

* 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：

## 四 、缓存策略

### 1、缓存过程分析

* 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：

<img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-11-18.png" style="zoom:50%;" />

### 2、强制缓存

* 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

  不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：

<img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-23-18.png" style="zoom:50%;" />

* 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图：

<img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-25-11.png" style="zoom:50%;" />

* 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图：

<img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-26-52.png" style="zoom:50%;" />

* 那么强制缓存的缓存规则是什么？
  * 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

### 3、协商缓存

* 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

  * 协商缓存生效，返回304，如下：

  <img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-29-42.png" style="zoom:50%;" />

  * 协商缓存失效，返回200和请求结果结果，如下

  <img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-30-37.png" style="zoom:50%;" />

* 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

### 4、总结

* 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：

<img src="E:\gitProject\kkNote\面试题\图片资源\Snipaste_2021-06-15_16-34-34.png" style="zoom:50%;" />

# HTML

## 五、HTML5常见面试题

1. #### HTML5 为什么只需要写 <!DOCTYPE HTML>？

   * HTML5不基于SGML（标准通用置标语言），因此不需要对DTD（文档类型定义）进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）；
   * HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型；

2. #### 对WEB标准以及W3C的理解与认识？

   * web标准规范要求，书写标签必须闭合、标签小写、不乱嵌套，可
     提高搜索机器人对网页内容的搜索几率；
   * 建议使用外链css和js脚本，从而达到结构与行为、结构与表现的
     分离，提高页面的渲染速度，能更快地显示页面的内容；
   * 样式与标签的分离，更合理的语义化标签，使内容能被更多的用户
     所访问、内容能被更广泛的设备所访问、更少的代码和组件， 从而降低
     维护成本、改版更方便；
   * 不需要变动页面内容，便可提供打印版本而不需要复制内容，提高
     网站易用性；

3. 简述一下你对HTML语义化的理解？

   * 用正确的标签做正确的事情；
   * html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；
   * 即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的；
   * 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO；

4. 页面导入样式时，使用link和@import有什么区别？

   * link属于XHTML标签，而@import是css提供的；
   * 页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载；
   * @import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；
   * link方式的样式的权重高于@import的权重。

5. 如何区分 HTML 和 HTML5？

   * 在文档类型声明上不同：
     HTML是很长的一段代码，很难记住，而HTML5却只有简简单单的声明，方便记忆。

   * 在结构语义上不同：
     HTML：没有体现结构语义化的标签，通常都是这样来命名的<div id="header"></div>，这样表示网站的头部。

     HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：<header><article>

6. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

   * <!Doctype>声明位于文档中的最前面，处于<html>标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档

   * 严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。

   * 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

   * DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

7. 新的HTML5文档类型和字符集是？

   * HTML5文档类型 <!doctype html>
   * HTML5使用UTF-8字符集 <meta charset="UTF-8">

8. 如何处理HTML5新标签的浏览器兼容问题？

   * IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。
   * 使用是html5shim框架

9. HTML5 Canvas元素有什么用？

   * Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在HTML上进行图形操作，

10. HTML5存储类型有什么区别？

    * HTML5能够本地存储数据，在之前都是使用cookie使用的，HTML5提供了下面两种本地存储方案：
    * localStorage用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。
    *  sessionStorage 同一个会话的页面才能访问并且当会话结束后数据也会随之销毁，因此sessionStorage不是一种持久化的本地













